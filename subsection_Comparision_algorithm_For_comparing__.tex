\subsection{Comparision algorithm}
For comparing values of two word processor we just need to do a simple XOR operation. If we apply XOR on two word processor in fact we are comparing two words bit by bit and the result would be another word processor having 0 if two bits in the same position matched otherwise it's 1. In VHD each bit is coding one character in a read. Thus, our XOR result shows how many of \emph{base pairs (bp)} between two strings matched (0s) and how many didn't match (1s).
Since we are coding our base pairs with three bits, we should do XOR for each level separately and then accumulate our final result with applying OR operation  on all results. With this approach our final result would be a word processor which each of its bit will tell us that whether two \textit{bp}s from two different strings matched or not. Next step would be computing number of miss matches between two strings. Since we have segmented our string into multiple segments for the last step we need to sum up each segment's result and then compare it with the user defined threshold \textit{e}. Figure \ref{fig:fig3} shows following procedure.
  
\begin{figure}
\end{figure}

\subsection{Filtering}
As we mentioned in the introduction part user defined error threshold is usually equal to just $5\%$ of mappings length and read's length is usually between 80 till 120 bps which means our error threshold won't be bigger than 5 or 6 errors and as a result nearly $98\%$ of our mappings would be incorrect. These numbers show that if we don't filter out our data approximately $98\%$ of our computation would be useless. 

First step for filtering out our data is to computing number of errors and comparing it with \emph{e} for each segment. Instead of summing up segment's results and do comparision with \emph{e} in the last step we can compare each segment's result with \emph{e} sepratly. Therefore, we are doing more operations for correct reads since instead of counting number of ones in the result vector once and then compare it with the error threshold we are counting number of ones per each segment and then compare it with error thershold.  But the point is we are doing these additional computations for just $2\%$ of our total reads and for the rest of the reads we are saving instructions because now per each segment we can decide that whether we have passed error threshold or not and if yes we can stop comparision operation for that read and start comparing next read with our reference. Now base on our word processor's length (\emph{w}) and our read's length (\emph{l}) we can compute number of operations we are doing for each read.

\begin{equation}
\nonumber
n_{operations} = n_{XOR} + n_{OR} + n_{popcnt} + n_{gt} \\
n_{segments} =  \lceil \frac{l}{w} \rceil \\
n_{XOR} = n_{segments} \times (k-1) \\
n_{OR} = n_{segments} \times (k-1) \\
n_{popcnt} = n_{gt} = n_{segment} \\

\end{equation}  
  
Now number of operations we are doing to comparing reads with a reference would be depend on the size of our word processor. In modern CPUs $w$ is usually 32 or 64 (and if we use SIMD operations our register's length can be 128 or more). For instance if our word processor length is equal to 64 and our read's length is 100 then first segment would contain $64\%$ of our read. In other words we still using big portion of reads to determine should we continue our comparison procedure or should we stop since even in the first $64\%$ number of errors exceed \emph{e}. According to Figure ... using first $64\%$ of each reads can filter out nearly .... of our data with comparing just first segment.
But what if we can answer this fact with even less comparison. For instance with only using $16\%$ of our read and comparing it with our reference we can answer the question
  